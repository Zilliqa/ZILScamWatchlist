scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)
import IntUtils
library FungibleToken

let one_msg = 
  fun (msg : Message) => 
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

(* Error events *)
type Error =
| CodeIsNotManager
| CodeManagerExists
| CodeManagerNotExists


let make_error =
  fun (result : Error) =>
    let result_code = 
      match result with
      | CodeIsNotManager     => Int32 -1
      | CodeManagerExists    => Int32 -2
      | CodeManagerNotExists => Int32 -3
      end
    in
    { _exception : "Error"; code : result_code }
  
let zero = Uint128 0

(* Dummy user-defined ADT *)
type Unit =
| Unit

let get_val =
  fun (some_val: Option Uint128) =>
  match some_val with
  | Some val => val
  | None => zero
  end

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract ScamManagement
(
  contract_owner: ByStr20,
  name : String,
  init_scam_token_address: ByStr20,
  init_manager: ByStr20
)

(* Mutable fields *)

(* List of minters available *)
field managers: Map ByStr20 Unit 
  = let emp_map = Emp ByStr20 Unit in
    let authorize = Unit in
    builtin put emp_map init_manager authorize
    
field scam_token_address: ByStr20 = init_scam_token_address
(**************************************)
(*             Procedures             *)
(**************************************)

procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

(* @dev:   Checks if address is in manager list                   *)
(* @param: manager: Address of the manager to be checked          *)
(* Returns error event CodeIsNotManager if manager is not in list *)
procedure isManager(address: ByStr20)
  some_manager <- managers[address];
  match some_manager with
  | None =>
    err = CodeIsNotManager;
    ThrowError err   
  | Some Unit => 
  end
end

(***************************************)
(*             Transitions             *)
(***************************************)

(* @dev:   Add approved managers. Only existing managers can add managers. *)
(* @param: manager: Address of the manager to be approved                  *)
(* Returns error event CodeManagerExists if manager already approved       *)
transition addManagers(manager: ByStr20)
  isManager _sender;
  some_manager <- managers[manager];
  match some_manager with
  | Some Unit => 
    err = CodeManagerExists;
    ThrowError err
  | None =>
    authorize = Unit;
    managers[manager] := authorize;
    (* Emit success event *)
    e = {_eventname: "AddManagerSuccess"; manager: manager};
    event e
  end
end

(* @dev:   Remove approved managers. Only existing managers can remove managers. *)
(* @param: manager: Address of the manager to be remove                          *)
(* Returns error event CodeManagerNotExists if manager is already not approved   *)
transition removeManagers(manager: ByStr20)
  isManager _sender;
  some_manager <- managers[manager];
  match some_manager with
  | Some Unit => 
    delete managers[manager];
    (* Emit success event *)
    e = {_eventname: "RemoveManagerSuccess"; manager: manager};
    event e
  | None =>
    err = CodeManagerNotExists;
    ThrowError err
  end
end

(* @dev:   Change scam_token_address field to new_scam_token_address   *)
(* @param: new_scam_token_address: scam token address to be changed to *)
transition ChangeScamTokenAddress(new_scam_token_address: ByStr20)
  isManager _sender;
  scam_token_address := new_scam_token_address;
  e = {_eventname: "ChangedScamTokenAddress"; new_scam_token_address: new_scam_token_address};
  event e  
end

(* @dev:   Call ChangeManager transition from ScamToken contract   *)
(* @param: new_manager: management contract to be changed to       *)
transition callChangeManager(new_manager: ByStr20)
  isManager _sender;
  address <- scam_token_address;
  msg_to_scam_token = {_tag: "ChangeManager"; _recipient: address; _amount: zero; new_manager: new_manager};
  msgs = one_msg msg_to_scam_token;
  send msgs
end

(* @dev:   Call Mint transition from ScamToken contract                       *)
(* @param: recipient: Address of the recipient whose balance is to increase.  *)
(* @param: amount:    Number of tokens to be minted.                          *)
transition callMint(recipient: ByStr20, amount: Uint128)
  isManager _sender;
  address <- scam_token_address;
  msg_to_scam_token = {_tag: "Mint"; _recipient: address; _amount: zero; recipient: recipient; amount: amount};
  msgs = one_msg msg_to_scam_token;
  send msgs
end

(* @dev:   Call Burn transition from ScamToken contract                            *)
(* @param: burn_account: Address of the token_owner whose balance is to decrease.  *)
(* @param: amount:       Number of tokens to be burned.                            *)
transition callBurn(burn_account: ByStr20, amount: Uint128)
  isManager _sender;
  address <- scam_token_address;
  msg_to_scam_token = {_tag : "Burn"; _recipient : address; _amount : zero; 
                    burn_account : burn_account; amount : amount};
  msgs = one_msg msg_to_scam_token;
  send msgs
end

(* @dev:   Call Transfer transition from ScamToken contract             *)
(* @param: to:     Address of the recipient whose balance is increased. *)
(* @param: amount: Amount of tokens to be sent.                         *)
transition callTransfer(from: ByStr20, to: ByStr20, amount: Uint128)
  isManager _sender;
  address <- scam_token_address;
  msg_to_scam_token = {_tag : "Transfer"; _recipient : address; _amount : zero; 
                  from: from; to : to; amount : amount};
  msgs = one_msg msg_to_scam_token;
  send msgs
end